---
schema: '1.0'
name: evolve
version: 3.7.1
description: 自我進化 Agent：給定目標，自主學習並迭代改進直到完成。觸發詞：evolve、進化、自我學習、迭代改進、達成目標。
triggers:
  - evolve
  - 進化
  - 自我學習
  - 迭代改進
  - 達成目標
  - self-evolving
  - autonomous
  - goal-oriented
keywords:
  - agent
  - learning
  - pdca
  - memory
  - skill-acquisition
  - emergence
---
# Self-Evolving Agent v3.7.1

> PSB 環境檢查 → 目標分析 → **自動領域識別** → 評估能力 → 習得技能 → PDCA 執行 → 診斷 → 多策略重試 → Repo 記憶 → 直到成功

---

## 核心哲學：AI 協作的抽象化範式

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  人類與 AI 協作的本質：透過抽象化介面溝通                       │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  傳統程式設計          →    AI 時代                      │   │
│  │  ───────────────           ─────────                     │   │
│  │  人類 → 程式語言 → 電腦    人類 → 抽象介面 → AI → 執行   │   │
│  │          ↓                         ↓                     │   │
│  │        精確控制               意圖傳達 + 能力授權         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  對應關係：                                                     │
│  ┌──────────────┬──────────────┬────────────────────────┐      │
│  │ 傳統軟體     │ AI 協作      │ 作用                   │      │
│  ├──────────────┼──────────────┼────────────────────────┤      │
│  │ API          │ MCP          │ 能力邊界（能做什麼）   │      │
│  │ SDK/Library  │ Tools        │ 具體實作（怎麼做）     │      │
│  │ 文檔+實踐    │ Skill        │ 領域知識（何時用什麼） │      │
│  │ Config       │ CLAUDE.md    │ 上下文約束（專案規範） │      │
│  └──────────────┴──────────────┴────────────────────────┘      │
│                                                                 │
│  深層洞察：                                                     │
│  • Skill 不只是知識，是「封裝好的判斷力」                       │
│  • 告訴 AI 在什麼情況下，用什麼方式，達成什麼目標               │
│  • 減少決策點 > 讓 AI 自己選擇                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 設計原則

| 原則 | 說明 |
|------|------|
| **有主見的設計** | 合理預設值 > 讓 AI 選擇，必填參數 ≤ 2 個 |
| **深且窄** | 專注 10% 高價值任務，不追求功能廣度 |
| **預期失敗** | 95% Agent 在生產環境失敗是常態，設計優雅降級 |
| **增強回饋** | 執行中提醒目標和進度，失敗時說明影響範圍 |

---

## 🚨 強制檢查點（Mandatory Checkpoints）

> **以下檢查點不可跳過，是從「指南」變「護欄」的關鍵**

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  從「指南」變「護欄」：                                         │
│                                                                 │
│  指南 = 告訴你該怎麼做（可以不聽）                              │
│  護欄 = 強制你不能偏離（無法繞過）                              │
│                                                                 │
│  以下三個檢查點是「護欄」，必須執行：                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Checkpoint 1: 任務開始前 - 主動查 Memory

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  🔍 任務開始前（強制）                                          │
│                                                                 │
│  執行任何任務前，必須先搜尋相關經驗：                           │
│                                                                 │
│  □ grep -r "關鍵字" .claude/memory/                            │
│  □ 有找到 → 閱讀並應用                                         │
│  □ 沒找到 → 記錄「無相關經驗」，繼續執行                       │
│                                                                 │
│  ❌ 禁止：不查 memory 就開始執行                                │
│  ✅ 必須：每個任務開始前都執行搜尋                              │
└─────────────────────────────────────────────────────────────────┘
```

### Checkpoint 2: 程式碼變更後 - 編譯 + 測試

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  🔨 程式碼變更後（強制）                                        │
│                                                                 │
│  任何程式碼變更後，必須驗證：                                   │
│                                                                 │
│  □ 編譯通過（最低門檻，不可跳過）                               │
│    - npm run build / tsc / python -m py_compile                 │
│    - 編譯失敗 → 禁止繼續下一個任務                              │
│                                                                 │
│  □ 相關測試通過（如果有的話）                                   │
│    - npm test -- --related / pytest                             │
│    - 測試失敗 → 修復後才能繼續                                  │
│                                                                 │
│  ❌ 禁止：連續修改多個檔案不驗證                                │
│  ❌ 禁止：編譯失敗還繼續下一個任務                              │
│  ✅ 必須：每次變更後立即驗證                                    │
└─────────────────────────────────────────────────────────────────┘
```

### Checkpoint 3: Milestone 完成後 - 目標確認

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  🎯 Milestone 完成後（強制）                                    │
│                                                                 │
│  每個 Milestone 完成時，必須回答三個問題：                      │
│                                                                 │
│  1. 現在的目標是什麼？                                          │
│     → 重新確認當前要達成的目標                                  │
│                                                                 │
│  2. 方向有沒有偏離目標？                                        │
│     → 檢視已完成的工作是否朝向目標前進                          │
│                                                                 │
│  3. 下一步是什麼？                                              │
│     → 明確下一個行動，而非盲目繼續                              │
│                                                                 │
│  ❌ 禁止：用戶說「繼續」就盲目繼續                              │
│  ❌ 禁止：完成後直接跳到下一個而不回顧                          │
│  ✅ 必須：主動報告進度並等待確認                                │
└─────────────────────────────────────────────────────────────────┘
```

### Checkpoint 3.5: Memory 同步 - 即時更新 index.md (v3.7.1 新增)

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  📝 Memory 同步（強制）                                         │
│                                                                 │
│  每次創建 memory 文件後，必須**立即**同步 index.md：            │
│                                                                 │
│  □ Write(.claude/memory/learnings/xxx.md)                       │
│    → 立即 Edit(.claude/memory/index.md) 加入條目                │
│                                                                 │
│  □ Write(.claude/memory/failures/xxx.md)                        │
│    → 立即 Edit(.claude/memory/index.md) 加入條目                │
│                                                                 │
│  □ Write(.claude/memory/decisions/xxx.md)                       │
│    → 立即 Edit(.claude/memory/index.md) 加入條目                │
│                                                                 │
│  背景：                                                         │
│  - 實際案例：創建了多個 ADR 記錄文件但忘記更新 index.md          │
│  - 用戶反饋：「我看.claude/memory沒有新的紀錄」                  │
│  - 原因：儲存與索引是兩個分離的動作，容易忽略後者                │
│                                                                 │
│  ❌ 禁止：創建 memory 文件但不更新 index.md                     │
│  ❌ 禁止：批量創建多個 memory 後才一次更新 index                 │
│  ✅ 必須：Write memory → Edit index → 驗證 三步一體             │
│  ✅ 必須：Commit 前確認 index.md 與實際文件數量匹配              │
└─────────────────────────────────────────────────────────────────┘
```

### Checkpoint 4: 迭代完成後 - 涌現機會檢查 (v3.6 新增)

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  🌱 涌現機會檢查（選擇性但推薦）                                │
│                                                                 │
│  每次迭代完成後，問自己：                                       │
│                                                                 │
│  1. 這次改進是否開啟了新的可能性？                              │
│     → 如果是，記錄並考慮探索                                    │
│                                                                 │
│  2. 是否發現了非預期的連結？                                    │
│     → skill A 和 skill B 可以組合？                            │
│     → 這個模式可以應用到其他地方？                              │
│                                                                 │
│  3. 有沒有「意外發現」值得追蹤？                                │
│     → 記錄到 .claude/memory/discoveries/                       │
│                                                                 │
│  4. 如果還有剩餘迭代，可以探索什麼？                            │
│     → 不一定要用完，但可以用於探索性改進                        │
│                                                                 │
│  ✅ 鼓勵：記錄意外發現，即使不立即使用                         │
│  ✅ 鼓勵：提出「如果...會怎樣」的假設                          │
│  ✅ 鼓勵：嘗試跨領域連結                                       │
└─────────────────────────────────────────────────────────────────┘
```

---

## 核心理念：PSB + PDCA 整合框架

```
┌─────────────────────────────────────────────────────────────────┐
│                  Self-Evolving Loop v3.5                        │
│            (PSB + PDCA + Auto Domain Detection)                 │
│                                                                 │
│  ╔═══════════════════════════════════════════════════════════╗ │
│  ║  PSB System (環境準備)                                     ║ │
│  ║  ┌────────┐   ┌────────┐   ┌────────┐                     ║ │
│  ║  │  Plan  │ → │ Setup  │ → │ Build  │                     ║ │
│  ║  │ 規劃   │   │ 環境   │   │ 執行   │                     ║ │
│  ║  └────────┘   └────────┘   └────────┘                     ║ │
│  ╚═══════════════════════════════════════════════════════════╝ │
│                            ↓                                    │
│    ┌──────────┐                                                │
│    │   目標   │  ← Phase 1: 目標分析                          │
│    └────┬─────┘                                                │
│         ↓                                                       │
│    ┌──────────────┐                                            │
│    │ 能力邊界評估 │  ← Phase 1.5: 先評估會什麼、缺什麼        │
│    └──────┬───────┘                                            │
│           ↓                                                     │
│    ┌──────────────┐     ┌──────────────┐                       │
│    │ Skill 習得   │ ──→ │   驗證學習   │                       │
│    │ (recommend/  │     │   (簡單測試) │                       │
│    │  install)    │     └──────┬───────┘                       │
│    └──────────────┘            ↓                               │
│         ↓                                                       │
│  ╔═══════════════════════════════════════════════════════════╗ │
│  ║  PDCA Cycle (執行循環)                                     ║ │
│  ║  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   ║ │
│  ║  │   Plan   │→ │    Do    │→ │  Check   │→ │   Act    │   ║ │
│  ║  │  (規劃)  │  │  (執行)  │  │ (失敗診斷)│  │ (改進)   │   ║ │
│  ║  └──────────┘  └──────────┘  └──────────┘  └────┬─────┘   ║ │
│  ║       ↑                                         │          ║ │
│  ║       └─────────── 多策略選擇 ←─────────────────┘          ║ │
│  ╚═══════════════════════════════════════════════════════════╝ │
│                            │                                    │
│                     ┌──────▼───────┐                            │
│                     │  Git-based   │  ← Git 版本控制記憶        │
│                     │    Memory    │                            │
│                     └──────────────┘                            │
│                                                                 │
│    重複直到：目標達成 或 達到最大迭代次數                       │
└─────────────────────────────────────────────────────────────────┘
```

### PSB System 說明

**P**lan → **S**etup → **B**uild：在寫第一行程式碼前，先確保環境就緒。

| 階段 | 目的 | 檢查項目 |
|------|------|----------|
| **Plan** | 釐清所有細節 | 目標、範圍、成功標準 |
| **Setup** | 建立自動化環境 | 記憶系統、CLAUDE.md、MCP |
| **Build** | MVP 優先執行 | PDCA 循環、多 Agent 協作 |

## 版本更新重點

### v3.5 新增（自動領域識別）

| 能力 | 說明 |
|------|------|
| **自動領域識別** | 從任務描述提取關鍵詞，自動搜尋並載入匹配的領域 skill |
| **Triggers 機制** | 每個領域 skill 定義觸發詞（中英文），用於智慧匹配 |
| **優雅降級** | 沒有匹配的領域 skill 時，不阻斷流程，繼續執行 |
| **領域來源** | 支援 `claude-software-skills`（技術）+ `claude-domain-skills`（非技術） |

### v3.4 新增（Boris Cherny Tips 整合）

| 能力 | 說明 | 來源 |
|------|------|------|
| **強化驗證迴圈** | PDCA Check 階段加入自動化驗證策略，品質提升 2-3 倍 | Tip #13 |
| **Subagent 策略** | verify-app, code-simplifier, build-validator 子代理 | Tip #8 |
| **Hooks 整合** | PostToolUse 自動格式化、Stop hook 完成驗證 | Tips #9, #12 |
| **長時間任務處理** | ralph-wiggum 整合、Background Agent、Permission 優化 | Tip #12 |

### v3.3 新增

| 能力 | 說明 |
|------|------|
| **強制檢查點** | 三個不可跳過的護欄：任務前查 Memory、變更後編譯測試、Milestone 後目標確認 |
| **Memory 生命週期** | 去蕪存菁：合併、標註過時、加上下文、刪除 |
| **整理觸發時機** | Milestone 完成、條目超過 20 筆、新舊衝突、定期整理 |
| **index.md Metadata** | 新增 Last curated、Total entries、Next review 等欄位 |

### v3.2 功能

| 能力 | 說明 |
|------|------|
| **核心哲學** | AI 協作的抽象化範式：MCP=能力邊界、Skill=判斷力、CLAUDE.md=約束 |
| **PSB 整合** | Plan-Setup-Build 環境準備，確保環境就緒再執行 |
| **設計原則** | 有主見的設計、深且窄、預期失敗、增強回饋 |
| **Phase -1** | 新增環境準備階段，7 步驟檢查清單 |

### v3.0/v3.1 功能

| 能力 | 說明 |
|------|------|
| **Git-based Memory** | 記憶存於 `.claude/memory/`，版本控制，可追溯、可回滾、可協作 |
| **Skill 自動習得** | 整合 skillpkg MCP，自動搜尋/安裝/載入 skills |
| **失敗模式診斷** | 分類失敗類型，針對性處理 |
| **能力邊界感知** | 執行前評估自己會什麼、缺什麼 |
| **多策略嘗試** | 不重複同一策略，從策略池選擇 |
| **結構化經驗** | Markdown 格式，可用 Grep 檢索 |

## 使用方式

```
觸發詞：/evolve [目標描述]

範例：
/evolve 建立一個能自動生成遊戲道具圖片的 ComfyUI 工作流程
/evolve 優化這段程式碼的效能，目標是降低 50% 執行時間
/evolve 為這個專案建立完整的測試覆蓋率達到 80%
```

---

## Phase -1: 環境準備 (PSB Setup)

> **在寫第一行程式碼前，先確保環境就緒**

### PSB 7 步驟檢查清單

```
┌─────────────────────────────────────────────────────────────────┐
│  PSB Setup Checklist                                            │
│                                                                 │
│  執行 /evolve 前，依序檢查以下項目：                            │
│                                                                 │
│  ┌─ Plan（規劃）──────────────────────────────────────────────┐│
│  │  □ 1. 目標明確性                                           ││
│  │     - 成功標準已定義？                                     ││
│  │     - 範圍已限定？                                         ││
│  │     - 驗收條件可量化？                                     ││
│  └────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ Setup（環境）─────────────────────────────────────────────┐│
│  │  □ 2. Git Repo 已建立                                      ││
│  │     - git init / git clone                                 ││
│  │     - .gitignore 配置完成                                  ││
│  │                                                            ││
│  │  □ 3. CLAUDE.md 專案記憶已配置                              ││
│  │     - 專案規範、技術棧、約定                               ││
│  │     - 參考：專案根目錄的 CLAUDE.md                         ││
│  │                                                            ││
│  │  □ 4. 記憶系統已初始化                                     ││
│  │     - .claude/memory/ 目錄結構                             ││
│  │     - index.md 索引檔案                                    ││
│  │                                                            ││
│  │  □ 5. 自動化文件已設定（可選）                             ││
│  │     - 架構文件、變更日誌、進度追蹤                         ││
│  │                                                            ││
│  │  □ 6. MCP 連接已配置（可選）                               ││
│  │     - skillpkg（Skill 管理）                               ││
│  │     - context7（文檔查詢）                                 ││
│  │     - PAL（多模型協作）                                    ││
│  │                                                            ││
│  │  □ 7. Slash Commands 已設定（可選）                        ││
│  │     - /evolve 觸發詞                                       ││
│  │     - 其他自動化指令                                       ││
│  └────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ Build（執行）─────────────────────────────────────────────┐│
│  │  ✓ 環境就緒，開始 Phase 0 → Phase 1 → PDCA 循環            ││
│  └────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

### 快速檢查指令

```bash
# 檢查 Git
git status

# 檢查 CLAUDE.md
ls CLAUDE.md 2>/dev/null || echo "⚠️ 建議建立 CLAUDE.md"

# 檢查記憶系統
ls .claude/memory/ 2>/dev/null || echo "⚠️ 需要初始化記憶系統"
```

### 最小可行環境

若要快速開始，至少確保：

| 必要 | 項目 | 說明 |
|------|------|------|
| ✅ | Git Repo | 版本控制 |
| ✅ | `.claude/memory/` | 記憶儲存 |
| 建議 | `CLAUDE.md` | 專案約束 |
| 可選 | MCP 配置 | 擴展能力 |

---

## Phase 0: 初始化記憶系統

首次使用時，檢查並建立記憶目錄結構：

```bash
# 檢查記憶目錄是否存在
ls .claude/memory/ 2>/dev/null || echo "需要初始化"
```

若不存在，建立以下結構：

```
.claude/memory/
├── index.md              # 快速索引（必須維護）
├── learnings/            # 學習記錄
│   └── .gitkeep
├── decisions/            # 決策記錄 (ADR)
│   └── .gitkeep
├── failures/             # 失敗經驗
│   └── .gitkeep
├── patterns/             # 推理模式
│   └── .gitkeep
└── strategies/           # 策略記錄
    └── .gitkeep
```

**初始化 index.md 模板：**

```markdown
# 專案記憶索引

> 自動維護，請勿手動編輯主要區塊

## 最近學習
<!-- LEARNINGS_START -->
<!-- LEARNINGS_END -->

## 重要決策
<!-- DECISIONS_START -->
<!-- DECISIONS_END -->

## 失敗經驗
<!-- FAILURES_START -->
<!-- FAILURES_END -->

## 推理模式
<!-- PATTERNS_START -->
<!-- PATTERNS_END -->

## 策略記錄
<!-- STRATEGIES_START -->
<!-- STRATEGIES_END -->

## 標籤索引
<!-- TAGS_START -->
<!-- TAGS_END -->
```

---

## Phase 1: 目標分析

```markdown
0. 目標明確性檢查（優先執行）
   ┌─────────────────────────────────────────────────────────┐
   │  檢查項目：                                             │
   │  □ 有具體的成功標準嗎？                                │
   │  □ 有可量化的驗收條件嗎？                              │
   │  □ 範圍是否明確？                                      │
   │  □ 有技術/資源約束嗎？                                 │
   │  □ 有時間/品質偏好嗎？                                 │
   └─────────────────────────────────────────────────────────┘

   若有 ≥2 項不明確 → 使用 AskUserQuestion 確認
   若只有 1 項不明確 → 用【假設】補齊，列出假設內容
   若全部明確 → 直接進入目標解析

1. 解析目標
   - 最終成功標準是什麼？
   - 如何驗證目標達成？
   - 有哪些約束條件？

2. 分解子目標
   - 將大目標拆成可執行的步驟
   - 識別依賴關係
   - 設定每個步驟的驗收標準

3. 評估現有能力
   - 需要哪些技能/工具？
   - 哪些已具備？哪些需要學習？
```

### 目標確認問卷（使用 AskUserQuestion）

當目標不明確時，**一次收齊**關鍵資訊：

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  ❓ 需要確認目標細節                                           │
│                                                                 │
│  您的目標：[用戶輸入的原始目標]                                 │
│                                                                 │
│  請幫我確認以下幾點：                                           │
│                                                                 │
│  1. 成功標準                                                    │
│     □ 能正常運作即可                                           │
│     □ 需要特定效能指標（請說明）                               │
│     □ 需要通過測試/驗收條件（請說明）                          │
│                                                                 │
│  2. 範圍限制                                                    │
│     □ 只處理核心功能                                           │
│     □ 需要完整實作（含邊界情況）                               │
│     □ 需要考慮擴展性                                           │
│                                                                 │
│  3. 品質 vs 速度                                                │
│     □ 快速完成優先（可接受後續優化）                           │
│     □ 品質優先（寧可慢也要做好）                               │
│     □ 平衡                                                     │
│                                                                 │
│  4. 其他約束                                                    │
│     □ 無特別限制                                               │
│     □ 有（請說明：技術棧/相容性/資源限制）                     │
└─────────────────────────────────────────────────────────────────┘
```

### 不明確目標範例

| 用戶輸入 | 缺少的資訊 | 需要確認 |
|----------|------------|----------|
| 「優化效能」 | 優化什麼？目標數值？ | ✅ |
| 「做一個網站」 | 什麼功能？什麼風格？ | ✅ |
| 「修好這個 bug」 | bug 現象？預期行為？ | ✅ |
| 「把這段程式碼重構成 TypeScript，要有型別定義」 | 全部明確 | ❌ |
| 「建立登入功能，要有 JWT 和刷新 token」 | 全部明確 | ❌ |

---

## Phase 1.5: 能力邊界評估

執行任務前，先進行自我能力評估。以下是評估時使用的**思考框架**：

```yaml
# ========================================
# 能力評估思考框架（範例，實際內容依任務而定）
# ========================================
task: "[分析用戶的任務後填入]"

capability_assessment:
  # 確定會的（根據實際情況填寫）
  confident_in:
    - skill: "[技能名稱]"
      level: "熟練 / 基本 / 略知"

  # 不確定的
  uncertain_about:
    - skill: "[技能名稱]"
      reason: "[為什麼不確定]"

  # 確定需要學習的
  definitely_need:
    - "[需要的技能或知識]"

  # 行動計劃
  action_plan:
    - step: "[下一步行動]"
      tool: "[使用的工具]"
```

**範例**（當任務是「用 ComfyUI 生成遊戲道具」時）：
```yaml
task: "用 ComfyUI 生成遊戲道具圖片"

capability_assessment:
  confident_in:
    - skill: "Python 程式設計"
      level: "熟練"
  uncertain_about:
    - skill: "ComfyUI 工作流程"
      reason: "從未使用過"
  definitely_need:
    - "ComfyUI 節點操作知識"
  action_plan:
    - step: "搜尋過去經驗"
      tool: "Grep .claude/memory/"
    - step: "搜尋 ComfyUI 相關 skill"
      tool: "recommend_skill"
```

**評估流程：**
```
任務分析 → 列出需要的能力 → 自評每項能力
    ↓
┌───────────────────────────────────────────┐
│  Step 0: 自動領域識別（v3.5 新增）        │
│                                           │
│  從任務描述提取關鍵詞，自動搜尋領域 skill │
│                                           │
│  search_skills(query="任務關鍵詞")        │
│      ↓                                    │
│  找到匹配 → 自動 load_skill               │
│  沒找到 → 繼續（graceful degradation）    │
└───────────────────────────────────────────┘
    ↓
┌───────────────────────────────────────────┐
│  對於每項「不確定」或「確定需要」的能力：  │
│                                           │
│  1. Grep 搜尋 .claude/memory/ 查找經驗    │
│  2. 沒有經驗 → recommend_skill 搜尋       │
│  3. 找到 skill → install + verify        │
│  4. 驗證通過 → 加入 confident_in         │
└───────────────────────────────────────────┘
    ↓
所有關鍵能力都在 confident_in → 開始執行
```

### 自動領域識別（Auto Domain Detection）

```
┌─────────────────────────────────────────────────────────────────┐
│  自動領域識別流程 v3.6（使用 MatchingEngine）                    │
│                                                                 │
│  用戶任務：「幫我建立一個量化交易回測系統」                     │
│                                                                 │
│  Step 1: 使用 recommend_skills 智慧匹配                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  recommend_skills({ goal: "量化交易回測系統" })          │   │
│  │                                                         │   │
│  │  → MatchingEngine 分析：                                │   │
│  │    • 提取關鍵詞：量化、交易、回測、系統                 │   │
│  │    • 匹配 primary keywords（權重 1.0）                  │   │
│  │    • 匹配 secondary keywords（權重 0.6）                │   │
│  │    • 計算整體信心度                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          ↓                                      │
│  Step 2: 獲得推薦結果                                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  domain_skills:                                         │   │
│  │    • quant-trading (85% confidence, high priority)      │   │
│  │      → 依賴: python, database, data-analysis            │   │
│  │                                                         │   │
│  │  software_skills:                                       │   │
│  │    • python (90% confidence)                            │   │
│  │    • database (75% confidence)                          │   │
│  │                                                         │   │
│  │  from_dependencies: [python, database, data-analysis]   │   │
│  │  overall_confidence: 0.83                               │   │
│  │  research_mode: false                                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          ↓                                      │
│  Step 3: 自動載入推薦的 skills                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  load_skill("quant-trading")     # 領域知識             │   │
│  │  load_skill("python")            # 軟體技能             │   │
│  │  load_skill("database")          # 軟體技能             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          ↓                                      │
│  Step 4: 執行任務（帶有完整知識棧）                             │
└─────────────────────────────────────────────────────────────────┘
```

**研究模式（Research Mode）：**

當整體信心度 < 50% 時，自動進入研究模式：

```
┌─────────────────────────────────────────────────────────────────┐
│  研究模式觸發                                                   │
│                                                                 │
│  overall_confidence: 0.35 (< 0.5 閾值)                          │
│  research_mode: true                                            │
│  research_suggestions:                                          │
│    • 搜尋外部 skill 倉庫：區塊鏈、智能合約                     │
│    • Web 搜尋最佳實踐："blockchain development"                │
│    • 詢問用戶澄清具體需求或技術                                │
│                                                                 │
│  → 不盲目執行，先補充知識再繼續                                │
└─────────────────────────────────────────────────────────────────┘
```

**領域 Skill 來源：**

| 來源 | 說明 |
|------|------|
| `claude-software-skills` | 軟體開發領域（前端、後端、DevOps...） |
| `claude-domain-skills` | 非技術領域（金融、行銷、遊戲設計...） |

**觸發詞匹配：**

每個領域 skill 定義 `triggers`（觸發詞），用於自動匹配：

```yaml
# finance/investment-analysis/SKILL.md (skillpkg 相容格式)
---
schema: "1.0"
name: investment-analysis
triggers: [股票, 財報, 投資, 估值, 基本面, stock, financial-report, investment, valuation]
keywords: [finance, investment, analysis]
---
```

**優雅降級：**

沒有找到匹配的領域 skill 時，不阻斷流程，繼續執行：

```
找到匹配 → 載入並增強能力
沒找到 → 記錄「無專門領域知識」，用通用能力執行
```

**實作範例：**

```python
# Step 1: 從用戶任務提取關鍵詞（AI 自動分析）
task = "幫我分析台積電的財報，判斷是否值得投資"
keywords = ["台積電", "財報", "投資"]  # AI 提取

# Step 2: 搜尋匹配的領域 skill（使用 skillpkg MCP）
search_skills({
    "query": " ".join(keywords),  # "台積電 財報 投資"
    "source": "local"  # 優先搜尋已安裝的
})
# → 結果：investment-analysis (匹配 triggers: 財報, 投資)

# Step 3: 載入領域知識
load_skill({ "id": "investment-analysis" })
# → 獲得：財報分析框架、估值模型、風險評估方法

# Step 4: 帶著領域知識執行任務
# AI 現在知道：
# - 如何解讀財報三表
# - PE/PB/ROE 等估值指標
# - 風險評估的框架
```

---

## Phase 2: 執行循環（PDCA）

每個子目標執行以下循環：

```markdown
┌─ Plan（規劃）─────────────────────────────────────────┐
│  - 制定具體執行計劃                                   │
│  - 預測可能的問題                                     │
│  - 準備備選方案                                       │
│                                                       │
│  🔍 Sharp Edges 檢查：                                │
│  □ 搜尋載入的 skills 的 sharp_edges 區塊              │
│  □ 識別當前任務可能觸發的陷阱                         │
│  □ 主動警告用戶並提供預防建議                         │
│                                                       │
│  🔀 Delegation 檢查：                                 │
│  □ 檢查當前 skill 的 delegation_triggers              │
│  □ 判斷任務是否匹配觸發條件                           │
│  □ 建議載入或委派給相關 skill                         │
│                                                       │
│  範例輸出：                                           │
│  ┌────────────────────────────────────────────────┐  │
│  │ ⚠️ Sharp Edge 警告：                           │  │
│  │   當前任務涉及「forEach + async」，這是常見陷阱 │  │
│  │   建議：使用 for...of 或 Promise.all           │  │
│  │                                                │  │
│  │ 🔀 Delegation 建議：                           │  │
│  │   觸發：API endpoint design                    │  │
│  │   建議載入：api-design skill                   │  │
│  └────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────┘
                          ↓
┌─ Do（執行）───────────────────────────────────────────┐
│  - 按計劃執行                                         │
│  - 記錄執行過程                                       │
│  - 收集中間結果                                       │
└───────────────────────────────────────────────────────┘
                          ↓
┌─ Check（評估）── Boris Tip #13: 驗證迴圈是王道 ───────┐
│  - 結果是否符合預期？                                 │
│  - 如果失敗，分析原因                                 │
│  - 評估：完全成功 / 部分成功 / 失敗                  │
│                                                       │
│  🔑 關鍵：給 Claude 驗證工作的方式，品質提升 2-3 倍   │
│                                                       │
│  自動化驗證策略：                                     │
│  □ 執行測試：npm test / pytest / go test             │
│  □ 執行構建：npm run build / tsc / cargo build       │
│  □ UI 測試：使用 Chrome extension 測試介面           │
│  □ Lint 檢查：eslint / prettier --check              │
│  □ 型別檢查：tsc --noEmit                            │
│                                                       │
│  ✅ Skill Validations 檢查（新增）：                  │
│  □ 搜尋載入的 skills 的 validations 區塊             │
│  □ 使用 regex/ast 模式掃描變更的程式碼               │
│  □ 報告違規並提供修復建議                            │
│                                                       │
│  範例：                                               │
│  ┌────────────────────────────────────────────────┐  │
│  │ 🔍 Validation 檢查結果：                       │  │
│  │                                                │  │
│  │ ❌ V-1: 發現空的 catch block                   │  │
│  │   位置：src/services/api.ts:45                 │  │
│  │   模式：catch\\s*\\([^)]*\\)\\s*\\{\\s*\\}    │  │
│  │   修復：加入 console.error(err) 或 throw err  │  │
│  │                                                │  │
│  │ ⚠️ V-2: 發現 console.log 未移除               │  │
│  │   位置：src/utils/helper.ts:12                 │  │
│  │   修復：移除或改用 logger                      │  │
│  └────────────────────────────────────────────────┘  │
│                                                       │
│  驗證失敗 → 不進入下一步，先修復                      │
└───────────────────────────────────────────────────────┘
                          ↓
┌─ Act（改進）──────────────────────────────────────────┐
│  如果成功：                                           │
│  - 記錄成功經驗到 .claude/memory/learnings/           │
│  - 更新 index.md                                      │
│  - 進入下一個子目標                                   │
│                                                       │
│  如果失敗：                                           │
│  - 反思：為什麼失敗？                                 │
│  - 學習：需要什麼新知識/技能？                       │
│  - 搜索：查找相關資料                                 │
│  - 更新：改進執行策略                                 │
│  - 記錄失敗到 .claude/memory/failures/                │
│  - 重試：帶著新知識重新執行                           │
└───────────────────────────────────────────────────────┘
```

---

## Phase 3: 反思與學習（Reflexion）

```markdown
每次失敗後的反思流程：

1. 失敗分析
   - 錯誤類型是什麼？（邏輯/語法/環境/理解）
   - 根本原因是什麼？
   - 是否遺漏了什麼？

2. 知識補充
   - 需要學習什麼？
   - 使用 WebSearch 搜索相關資料
   - 閱讀文檔或範例

3. 策略調整
   - 原策略哪裡有問題？
   - 新策略是什麼？
   - 如何避免同樣的錯誤？

4. 記憶更新
   - 將學到的經驗寫入 .claude/memory/
   - 格式：[情境] → [錯誤] → [解決方案]
   - 更新 index.md 索引
```

---

## Phase 4: 記憶系統 (Git-based Memory)

```markdown
Git-based 記憶架構：

┌─ .claude/memory/learnings/ ──────────────────────────┐
│  知識記憶（Knowledge Memory）                         │
│  - Codebase 知識、業務邏輯                            │
│  - 成功的解決方案、最佳實踐                           │
│  - 過去的互動經驗                                     │
│  格式：{date}-{slug}.md                               │
│  搜尋：Grep pattern=關鍵字 path=.claude/memory/       │
└───────────────────────────────────────────────────────┘

┌─ .claude/memory/patterns/ ───────────────────────────┐
│  推理記憶（Reasoning Patterns）                       │
│  - AI 推理步驟和問題解決模式                          │
│  - 策略演進記錄                                       │
│  - 可複用的思考框架                                   │
│  格式：{category}-{name}.md                           │
│  搜尋：Grep pattern=模式名 path=.claude/memory/patterns/│
└───────────────────────────────────────────────────────┘

┌─ .claude/memory/failures/ ───────────────────────────┐
│  失敗記憶（Failure Memory）                           │
│  - 失敗的嘗試和原因                                   │
│  - 避免重複踩坑                                       │
│  格式：{date}-{slug}.md                               │
│  搜尋：Grep pattern=錯誤關鍵字 path=.claude/memory/failures/│
└───────────────────────────────────────────────────────┘

┌─ .claude/memory/decisions/ ──────────────────────────┐
│  決策記錄（ADR - Architecture Decision Records）      │
│  - 重要的技術決策                                     │
│  - 選擇原因和取捨                                     │
│  格式：{number}-{title}.md                            │
│  搜尋：Grep pattern=決策關鍵字 path=.claude/memory/decisions/│
└───────────────────────────────────────────────────────┘

┌─ .claude/memory/strategies/ ─────────────────────────┐
│  策略記錄（Strategy Memory）                          │
│  - 各種任務類型的策略池                               │
│  - 策略成功率統計                                     │
│  格式：{task-type}.md                                 │
│  搜尋：Grep pattern=策略名 path=.claude/memory/strategies/│
└───────────────────────────────────────────────────────┘

Git-based 優勢：
✓ Git 版本控制，可追溯歷史
✓ 跨工具共享（Claude Code ↔ Copilot ↔ Cursor）
✓ 離線可用，無需外部服務
✓ 團隊協作，PR 審核記憶變更
✓ 可用標準工具搜尋（Grep/Glob）
✓ 專案相關，隨 repo 遷移
```

---

## Phase 4.5: Memory 生命週期管理

> **Memory 不是只進不出的垃圾桶，需要定期整理去蕪存菁**

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Memory 生命週期：                                              │
│                                                                 │
│  新增 → 累積 → 審視 → 去蕪存菁 → 精煉知識                       │
│                                                                 │
│  ❌ 錯誤：一直新增，從不整理 → 垃圾堆                           │
│  ✅ 正確：定期整理，保留精華 → 知識庫                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Memory 整理策略

| 操作 | 時機 | 做法 |
|------|------|------|
| **合併** | 同主題多筆記錄 | 整合成一筆精煉版 |
| **標註過時** | 有更好做法取代 | 加上 `[SUPERSEDED by xxx]` |
| **加上下文** | 情境限定的經驗 | 註明「適用於 v1，v2 不適用」 |
| **刪除** | 完全過時或錯誤 | 直接移除 |

### 觸發整理的時機

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  何時該整理 Memory？                                            │
│                                                                 │
│  1. 專案 Milestone 完成後                                       │
│     → 回顧本階段新增的經驗，是否需要整合                        │
│                                                                 │
│  2. Memory 條目超過 20 筆時                                     │
│     → 太多條目會影響搜尋效率                                    │
│                                                                 │
│  3. 發現新舊經驗衝突時                                          │
│     → 標註舊的為 SUPERSEDED                                     │
│                                                                 │
│  4. 定期（建議每週或每月）                                      │
│     → 避免債務累積                                              │
└─────────────────────────────────────────────────────────────────┘
```

### index.md 模板（含 Metadata）

```markdown
# 專案記憶索引

> Last curated: 2026-01-06
> Total entries: 15
> Next review: 2026-01-13 (7 days)

## 統計
- Learnings: 8 筆
- Failures: 4 筆
- Decisions: 2 筆
- Patterns: 1 筆

## 最近學習
<!-- LEARNINGS_START -->
- [2026-01-06] react-performance.md ⭐ (常用)
- [2026-01-03] api-error-handling.md
- [2025-12-28] old-approach.md [SUPERSEDED by react-performance.md]
<!-- LEARNINGS_END -->

## 重要決策
<!-- DECISIONS_START -->
<!-- DECISIONS_END -->

## 失敗經驗
<!-- FAILURES_START -->
<!-- FAILURES_END -->

## 推理模式
<!-- PATTERNS_START -->
<!-- PATTERNS_END -->

## 標籤索引
<!-- TAGS_START -->
<!-- TAGS_END -->
```

### Memory 整理 Checklist

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  Memory 整理 Checklist（每次整理時執行）                        │
│                                                                 │
│  □ 1. 有沒有重複/相似的條目？                                   │
│       → 合併成一筆                                              │
│                                                                 │
│  □ 2. 有沒有被新經驗取代的？                                    │
│       → 標註 [SUPERSEDED by xxx]                                │
│                                                                 │
│  □ 3. 有沒有超過 30 天未被引用的？                              │
│       → 評估是否仍然相關，不相關就刪除                          │
│                                                                 │
│  □ 4. 有沒有太長的條目？                                        │
│       → 精簡到只保留重點                                        │
│                                                                 │
│  □ 5. index.md 是否更新？                                       │
│       → 更新 Last curated 日期和統計數字                        │
└─────────────────────────────────────────────────────────────────┘
```

### 整理範例

**合併前：**
```
learnings/
├── 2026-01-01-react-memo.md        # React.memo 用法
├── 2026-01-03-usememo-hook.md      # useMemo 用法
└── 2026-01-05-performance-tips.md  # 效能優化技巧
```

**合併後：**
```
learnings/
└── 2026-01-05-react-performance.md  # 整合版：React 效能優化
    # 內容包含 memo, useMemo, useCallback 等完整知識
```

---

## 記憶操作指南

### 搜尋記憶

```python
# 搜尋學習記錄
Grep(
    pattern="ComfyUI",
    path=".claude/memory/learnings/",
    output_mode="files_with_matches"
)

# 搜尋失敗經驗
Grep(
    pattern="memory leak|記憶體",
    path=".claude/memory/failures/",
    output_mode="content",
    C=3  # 顯示上下文
)

# 搜尋推理模式
Grep(
    pattern="節點載入",
    path=".claude/memory/patterns/"
)

# 全域搜尋（所有記憶）
Grep(
    pattern="關鍵字",
    path=".claude/memory/"
)
```

### 儲存學習記錄

```python
# 檔名格式：{date}-{slug}.md
Write(
    file_path=".claude/memory/learnings/2025-01-05-comfyui-rembg.md",
    content="""---
date: 2025-01-05
tags: [comfyui, rembg, 透明背景, 遊戲素材]
task: 生成透明背景遊戲道具
status: resolved
---

# ComfyUI 生成透明背景圖片

## 情境
需要批量生成遊戲道具圖片，要求 PNG 透明背景

## 問題
預設輸出有白色背景，不適合遊戲使用

## 解決方案
1. 安裝 ComfyUI-Manager
2. 搜尋並安裝 RemBG 節點
3. 在工作流程最後加入 RemBG 節點
4. 輸出格式設為 PNG

## 驗證
✅ 成功生成透明背景圖片

## 注意事項
- 需要 4GB+ GPU 記憶體
- 處理速度約 2秒/張

## 相關檔案
- `workflows/game-assets.json`
"""
)

# 更新 index.md
Edit(
    file_path=".claude/memory/index.md",
    old_string="<!-- LEARNINGS_START -->",
    new_string="""<!-- LEARNINGS_START -->
- [ComfyUI 透明背景](learnings/2025-01-05-comfyui-rembg.md) - comfyui, rembg, 遊戲素材"""
)
```

### 儲存失敗經驗

```python
Write(
    file_path=".claude/memory/failures/2025-01-05-comfyui-memory-leak.md",
    content="""---
date: 2025-01-05
tags: [comfyui, memory-leak, gpu]
task: 批量生成圖片
status: unresolved
---

# ComfyUI 批量生成時記憶體洩漏

## 症狀
批量生成到第 5 張圖片時 GPU 記憶體耗盡

## 嘗試過的方案
1. ❌ 降低解析度 → 只延後問題
2. ❌ 使用 fp16 → 仍然洩漏
3. ⏳ 每張圖後手動清理 → 待測試

## 根本原因
ComfyUI 節點沒有正確釋放中間張量

## 待解決
- [ ] 研究 ComfyUI 記憶體管理機制
- [ ] 嘗試 --lowvram 參數
"""
)
```

### 儲存推理模式

```python
Write(
    file_path=".claude/memory/patterns/debug-node-loading.md",
    content="""---
category: debugging
name: 節點載入失敗診斷
applicable_to: [comfyui, node-based-tools]
---

# 節點載入失敗診斷模式

## 觸發條件
當遇到「節點載入失敗」、「模型未找到」等錯誤時

## 診斷步驟
1. 檢查檔案路徑是否正確
2. 確認檔案是否存在於預期目錄
3. 檢查節點類型是否匹配（如 LoraLoader vs Load LoRA）
4. 確認模型格式是否相容
5. 檢查是否缺少依賴節點

## 常見解決方案
- 重新安裝節點套件
- 檢查 models/ 目錄結構
- 使用 ComfyUI-Manager 重新載入

## 成功率
此模式解決問題的成功率：85%
"""
)
```

### 儲存策略記錄

```python
Write(
    file_path=".claude/memory/strategies/image-generation.md",
    content="""---
task_type: 圖片生成
last_updated: 2025-01-05
---

# 圖片生成策略池

## 策略列表

### S1: ComfyUI + RemBG (推薦)
- **優先級**: 1
- **適用**: 需要透明背景、批量生成
- **成功率**: 80%
- **需求**: GPU 4GB+, ComfyUI 環境
- **失敗記錄**: 記憶體洩漏問題（待解決）

### S2: Stable Diffusion API
- **優先級**: 2
- **適用**: 無本地 GPU、需要穩定性
- **成功率**: 95%
- **需求**: API Key, 網路連線
- **缺點**: 費用較高

### S3: DALL-E + 後處理
- **優先級**: 3
- **適用**: 快速原型、概念驗證
- **成功率**: 90%
- **需求**: OpenAI API Key
- **缺點**: 風格控制較弱

## 策略選擇邏輯
1. 有 GPU → 優先 S1
2. 無 GPU 或 S1 失敗 → S2
3. 需要快速出結果 → S3
"""
)
```

---

## 自我進化機制

### 1. 技能習得（整合 skillpkg MCP）

```markdown
當遇到無法完成的任務時：

┌─────────────────────────────────────────────────────────────────┐
│  技能習得流程 v3.0                                              │
│                                                                 │
│  1. 識別技能缺口                                                │
│     - 「我無法完成 X 因為我不知道如何 Y」                       │
│     - 區分：缺「知識」還是缺「工具」                            │
│                                                                 │
│  2. 搜尋已有經驗（Repo Memory）                                 │
│     Grep(pattern="Y", path=".claude/memory/")                   │
│     - 有經驗 → 直接應用                                         │
│     - 無經驗 → 繼續步驟 3                                       │
│                                                                 │
│  3. 搜尋可用 Skill                                              │
│     recommend_skill({ query: "Y", criteria: "popular" })        │
│     - 評估推薦的 skill 是否適用                                 │
│     - 查看 alternatives 比較選擇                                │
│                                                                 │
│  4. 安裝 Skill                                                  │
│     install_skill({ source: "best-skill-name" })                │
│     - 從 Registry / GitHub / URL 安裝                           │
│                                                                 │
│  5. 載入並學習                                                  │
│     load_skill({ id: "best-skill-name" })                       │
│     - 仔細閱讀 instructions                                     │
│     - 理解使用方式和限制                                        │
│                                                                 │
│  6. 驗證學習                                                    │
│     - 用簡單任務測試是否學會                                    │
│     - 成功 → 應用到實際任務                                     │
│     - 失敗 → 重新學習或換 skill                                 │
│                                                                 │
│  7. 記錄學習經驗                                                │
│     Write(.claude/memory/learnings/{date}-{skill}.md)           │
│     - 記錄情境 + skill + 效果                                   │
│     - 更新 index.md                                             │
└─────────────────────────────────────────────────────────────────┘
```

**Skill 習得範例：**
```
任務：用 ComfyUI 生成遊戲道具

1. 識別缺口：不會 ComfyUI
2. Grep(pattern="ComfyUI", path=".claude/memory/") → 無結果
3. recommend_skill({ query: "ComfyUI game assets" })
   → 推薦：comfyui-expert (⭐4.9, 2.1k downloads)
4. install_skill({ source: "comfyui-expert" })
   → 安裝成功
5. load_skill({ id: "comfyui-expert" })
   → 學習 instructions
6. 驗證：生成一張簡單測試圖
   → 成功！
7. Write(.claude/memory/learnings/2025-01-05-comfyui-expert.md)
   → 記錄經驗
```

### 2. 失敗模式診斷

失敗時先分類，再針對性處理：

```
┌─────────────────────────────────────────────────────────────────┐
│  失敗類型分類表                                                 │
│                                                                 │
│  類型 A: 知識缺口                                               │
│  ├─ 症狀：不知道怎麼做、沒見過這種問題                         │
│  ├─ 診斷：缺少領域知識或工具使用經驗                           │
│  └─ 處方：recommend_skill → install → learn                    │
│                                                                 │
│  類型 B: 執行錯誤                                               │
│  ├─ 症狀：知道怎麼做但做錯了、語法錯誤、參數錯誤               │
│  ├─ 診斷：粗心或理解不完整                                     │
│  └─ 處方：重新閱讀文檔、仔細檢查參數                           │
│                                                                 │
│  類型 C: 環境問題                                               │
│  ├─ 症狀：依賴缺失、版本不符、權限不足                         │
│  ├─ 診斷：環境配置問題                                         │
│  └─ 處方：修復環境、安裝依賴、切換版本                         │
│                                                                 │
│  類型 D: 策略錯誤                                               │
│  ├─ 症狀：方法正確但不適合當前情境                             │
│  ├─ 診斷：選錯了解決方案                                       │
│  └─ 處方：切換到策略池中的其他策略                             │
│                                                                 │
│  類型 E: 資源限制                                               │
│  ├─ 症狀：記憶體不足、API 限制、時間超時                       │
│  ├─ 診斷：硬體或服務限制                                       │
│  └─ 處方：優化資源使用、分批處理、換用輕量方案                 │
└─────────────────────────────────────────────────────────────────┘
```

**診斷流程：**
```
失敗發生 → 收集錯誤訊息 → 分類失敗類型 → 選擇對應處方 → 執行修復
     │
     └─ 記錄到 .claude/memory/failures/（避免重複踩坑）
```

### 3. 多策略機制

不重複嘗試同一個失敗策略，維護策略池進行智慧選擇：

```markdown
策略池結構（存於 .claude/memory/strategies/{task-type}.md）：

┌─────────────────────────────────────────────────────────────────┐
│  strategy_pool:                                                 │
│    current_task: "批量生成遊戲道具圖片"                         │
│                                                                 │
│    available_strategies:                                        │
│      - id: "s1"                                                 │
│        name: "ComfyUI + RemBG"                                  │
│        status: "untried"                                        │
│        priority: 1                                              │
│        requirements: ["comfyui", "rembg"]                       │
│                                                                 │
│      - id: "s2"                                                 │
│        name: "Stable Diffusion API + 透明背景模型"               │
│        status: "untried"                                        │
│        priority: 2                                              │
│        requirements: ["sd-api-key"]                             │
│                                                                 │
│      - id: "s3"                                                 │
│        name: "DALL-E + 後處理去背"                               │
│        status: "untried"                                        │
│        priority: 3                                              │
│        requirements: ["openai-key"]                             │
│                                                                 │
│    tried_strategies:                                            │
│      - id: "s1"                                                 │
│        result: "failed"                                         │
│        reason: "ComfyUI 安裝失敗"                               │
│        do_not_retry_until: "環境問題解決"                       │
└─────────────────────────────────────────────────────────────────┘

策略選擇邏輯：
1. 從 available_strategies 按 priority 排序
2. 跳過 status = "failed" 且 do_not_retry_until 未滿足的
3. 選擇第一個可行的策略
4. 如果所有策略都失敗 → 詢問用戶或搜尋新策略
```

### 4. 結構化經驗格式

經驗必須用可檢索的格式儲存：

```yaml
# .claude/memory/learnings/{date}-{slug}.md 模板
---
date: "2025-01-05"
tags: [tag1, tag2, tag3]
task: "任務描述"
status: "resolved | unresolved | partial"
---

# 標題

## 情境
[描述遇到這個問題的背景]

## 問題
[具體的問題描述]
- 症狀 1
- 症狀 2

## 解決方案
[詳細的解決步驟]
1. 步驟一
2. 步驟二
3. 步驟三

## 驗證
[如何確認問題已解決]
✅ 成功 / ❌ 失敗

## 注意事項
[額外的注意事項或限制]

## 相關檔案
- `path/to/file1`
- `path/to/file2`
```

### 5. 學習驗證流程

安裝新 skill 後，必須驗證真的學會才能應用：

```
┌─────────────────────────────────────────────────────────────────┐
│  學習驗證流程                                                   │
│                                                                 │
│  1. 安裝 Skill                                                  │
│     install_skill({ source: "comfyui-expert" })                 │
│                                                                 │
│  2. 載入 Instructions                                           │
│     load_skill({ id: "comfyui-expert" })                        │
│                                                                 │
│  3. 設計簡單驗證任務                                            │
│     ┌─────────────────────────────────────┐                    │
│     │  驗證任務應該：                      │                    │
│     │  • 範圍小、可快速完成               │                    │
│     │  • 涵蓋核心能力                     │                    │
│     │  • 有明確的成功標準                 │                    │
│     └─────────────────────────────────────┘                    │
│                                                                 │
│  4. 執行驗證                                                    │
│     ┌─────────────────────────────────────┐                    │
│     │  例：生成一張簡單的測試圖片          │                    │
│     │      檢查是否符合預期格式           │                    │
│     └─────────────────────────────────────┘                    │
│                                                                 │
│  5. 評估結果                                                    │
│     ✅ 成功 → 加入 confident_in，繼續主任務                    │
│     ❌ 失敗 → 重新學習或嘗試其他 skill                         │
└─────────────────────────────────────────────────────────────────┘
```

### 6. 策略進化

```markdown
追蹤每種策略的成功率（存於 .claude/memory/strategies/）：

策略選擇邏輯：
- 優先選擇成功率高的策略
- 失敗時切換到備選策略（參考多策略機制）
- 新情境時嘗試類比已知策略
- 所有策略都失敗時，搜尋新策略或詢問用戶
```

### 7. Prompt 自我優化

```markdown
根據執行結果調整自己的 Prompt：

原始 Prompt：
「生成一個遊戲道具圖片」

失敗後反思：
「生成的圖片背景不透明，不適合遊戲使用」

優化後 Prompt：
「生成一個遊戲道具圖片，要求：
 - 透明背景（PNG 格式）
 - 256x256 解析度
 - 卡通風格」

儲存優化後的 Prompt 模板到 .claude/memory/patterns/
```

### 8. Subagent 策略（Boris Tip #8）

> Boris 使用 code-simplifier, verify-app, build-validator 等 subagents

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  Subagent 策略池                                                │
│                                                                 │
│  將複雜任務分配給專門的子代理：                                 │
│                                                                 │
│  ┌─ verify-app ────────────────────────────────────────────────┐│
│  │  用途：驗證應用程式正確運作                                 ││
│  │  觸發：每次功能實作完成後                                   ││
│  │  動作：                                                     ││
│  │    1. 執行測試套件                                          ││
│  │    2. 啟動應用程式                                          ││
│  │    3. 測試關鍵路徑                                          ││
│  │    4. 報告驗證結果                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ code-simplifier ───────────────────────────────────────────┐│
│  │  用途：簡化複雜或冗長的程式碼                               ││
│  │  觸發：程式碼超過 200 行或複雜度過高                        ││
│  │  動作：                                                     ││
│  │    1. 識別重複模式                                          ││
│  │    2. 提取共用函數                                          ││
│  │    3. 簡化條件邏輯                                          ││
│  │    4. 保持功能不變                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ build-validator ───────────────────────────────────────────┐│
│  │  用途：驗證構建流程正確                                     ││
│  │  觸發：程式碼變更後                                         ││
│  │  動作：                                                     ││
│  │    1. 執行完整構建                                          ││
│  │    2. 檢查輸出檔案                                          ││
│  │    3. 驗證無警告/錯誤                                       ││
│  │    4. 報告構建狀態                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  使用方式：                                                     │
│  - 透過 Task tool 啟動 subagent                                 │
│  - 或在 .claude/memory/strategies/ 定義自訂 subagent            │
└─────────────────────────────────────────────────────────────────┘
```

**Subagent 策略模板（存於 `.claude/memory/strategies/subagents.md`）：**

```yaml
# Subagent 定義模板
subagents:
  verify-app:
    trigger: "功能實作完成"
    commands:
      - "npm test"
      - "npm run build"
      - "npm start & curl http://localhost:3000/health"
    success_criteria: "所有命令回傳 0"

  code-simplifier:
    trigger: "檔案超過 200 行"
    focus:
      - "重複程式碼"
      - "深層巢狀"
      - "過長函數"
    constraint: "不改變外部行為"

  build-validator:
    trigger: "程式碼變更"
    commands:
      - "npm run build"
      - "npm run lint"
      - "npm run typecheck"
    fail_action: "阻止進入下一步"
```

### 9. Hooks 整合（Boris Tips #9, #12）

> Boris 使用 PostToolUse hook 自動格式化，Stop hook 處理長時間任務

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  Claude Code Hooks 整合                                         │
│                                                                 │
│  ┌─ PostToolUse Hook ──────────────────────────────────────────┐│
│  │  用途：工具執行後自動處理                                   ││
│  │                                                             ││
│  │  範例：自動格式化程式碼                                     ││
│  │  配置（.claude/settings.json）：                            ││
│  │  {                                                          ││
│  │    "hooks": {                                               ││
│  │      "PostToolUse": [                                       ││
│  │        {                                                    ││
│  │          "matcher": "Edit|Write",                           ││
│  │          "command": "npx prettier --write $FILE"            ││
│  │        }                                                    ││
│  │      ]                                                      ││
│  │    }                                                        ││
│  │  }                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ Stop Hook ─────────────────────────────────────────────────┐│
│  │  用途：Agent 停止時執行驗證                                 ││
│  │                                                             ││
│  │  適用場景：                                                 ││
│  │  - 長時間任務完成後驗證結果                                 ││
│  │  - Background agent 完成後通知                              ││
│  │                                                             ││
│  │  配置：                                                     ││
│  │  {                                                          ││
│  │    "hooks": {                                               ││
│  │      "Stop": [                                              ││
│  │        {                                                    ││
│  │          "command": "npm test && npm run build"             ││
│  │        }                                                    ││
│  │      ]                                                      ││
│  │    }                                                        ││
│  │  }                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  /evolve 建議的 Hooks 配置：                                    │
│  - PostToolUse: 格式化、lint 檢查                               │
│  - Stop: 執行測試、構建驗證                                     │
└─────────────────────────────────────────────────────────────────┘
```

### 10. 長時間任務處理（Boris Tip #12 + ralph-wiggum）

> Boris 使用 ralph-wiggum plugin 做長時間任務的確定性處理

```markdown
┌─────────────────────────────────────────────────────────────────┐
│  長時間任務處理策略                                             │
│                                                                 │
│  問題：/evolve 的迭代循環可能耗時很長                           │
│                                                                 │
│  解決方案：                                                     │
│                                                                 │
│  ┌─ 方案 1: ralph-wiggum loop ─────────────────────────────────┐│
│  │  適用：需要確定性處理的長時間任務                           ││
│  │                                                             ││
│  │  啟動：/ralph-wiggum:ralph-loop                             ││
│  │  取消：/ralph-wiggum:cancel-ralph                           ││
│  │                                                             ││
│  │  特點：                                                     ││
│  │  - 持續監控任務進度                                         ││
│  │  - 自動處理中斷                                             ││
│  │  - 確保任務完成                                             ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ 方案 2: Background Agent ──────────────────────────────────┐│
│  │  適用：可以背景執行的獨立任務                               ││
│  │                                                             ││
│  │  使用 Task tool 的 run_in_background: true                  ││
│  │  搭配 Stop hook 驗證完成                                    ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  ┌─ 方案 3: Permission 優化 ───────────────────────────────────┐│
│  │  避免權限提示阻塞長時間任務                                 ││
│  │                                                             ││
│  │  推薦：/permissions（比 --dangerously-skip-permissions 安全）││
│  │  或：--permission-mode=dontAsk（在 sandbox 環境）           ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  /evolve 長時間任務建議流程：                                   │
│  1. 評估任務預期時間                                            │
│  2. 若 > 30 分鐘 → 考慮使用 ralph-wiggum                        │
│  3. 設定 Stop hook 驗證                                         │
│  4. 定期報告進度                                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 停止條件

```markdown
Agent 在以下情況停止：

✅ 成功條件：
   - 所有子目標完成
   - 驗收標準通過

❌ 失敗條件：
   - 達到最大迭代次數（預設 10 次）
   - 連續 3 次相同錯誤
   - 用戶手動中止

⚠️ 暫停條件：
   - 需要用戶決策
   - 需要外部資源
   - 風險操作需確認
```

---

## 完成輸出格式

```markdown
標準化完成信號（方便識別和工具整合）：

✅ 目標達成：
   ✅ GOAL ACHIEVED: [目標描述]

   範例：
   ✅ GOAL ACHIEVED: UserList 首次渲染 < 100ms

⏸️ 需要人工：
   ⏸️ NEED HUMAN: [原因]

   範例：
   ⏸️ NEED HUMAN: 架構選擇需要確認（方案 A vs B）

❌ 無法完成：
   ❌ CANNOT COMPLETE: [原因]

   範例：
   ❌ CANNOT COMPLETE: 連續 3 次相同錯誤，需要人工診斷
```

---

## 與用戶的互動

```markdown
進度報告（每個主要步驟後）：
┌─────────────────────────────────────────────────────┐
│  📊 進度更新                                        │
│                                                     │
│  目標：建立 ComfyUI 工作流程                        │
│  進度：███████░░░ 70%                               │
│                                                     │
│  ✅ 已完成：                                        │
│     - 安裝 ComfyUI                                  │
│     - 下載基礎模型                                  │
│     - 建立基本工作流程                              │
│                                                     │
│  🔄 進行中：                                        │
│     - 加入 LoRA 支援                                │
│                                                     │
│  ⏳ 待完成：                                        │
│     - 批量生成功能                                  │
│     - 輸出格式優化                                  │
│                                                     │
│  📝 學習記錄：                                      │
│     - 發現：LoRA 需要特定節點                       │
│     - 解決：安裝 ComfyUI-Manager                    │
│     - 已儲存到：.claude/memory/learnings/           │
└─────────────────────────────────────────────────────┘

需要確認時：
┌─────────────────────────────────────────────────────┐
│  ❓ 需要您的決定                                    │
│                                                     │
│  我嘗試了兩種方法都失敗了：                         │
│  1. 直接載入模型 → 記憶體不足                       │
│  2. 使用低精度模型 → 品質不佳                       │
│                                                     │
│  建議選項：                                         │
│  A. 使用雲端 GPU（需要費用）                        │
│  B. 降低輸出解析度（512→256）                       │
│  C. 換用更小的模型                                  │
│                                                     │
│  您希望怎麼做？                                     │
└─────────────────────────────────────────────────────┘
```

---

## 實作注意事項

### 安全機制

```markdown
1. 迭代上限
   - 防止無限循環
   - 預設最大 10 次嘗試

2. 範圍限制
   - 不執行危險操作（rm -rf 等）
   - 重要操作需用戶確認

3. 資源監控
   - 追蹤 API 呼叫次數
   - 避免過度消耗

4. 回滾機制
   - 每次重大變更前備份
   - 失敗時可以回滾
```

### 效能優化

```markdown
1. 快取成功經驗
   - 避免重複學習相同內容
   - 優先搜尋 .claude/memory/

2. 平行執行
   - 獨立的子任務可平行處理

3. 早期失敗檢測
   - 快速識別不可行的方向

4. 漸進式複雜度
   - 先嘗試簡單方案
   - 失敗後再嘗試複雜方案
```

---

## 與現有系統整合

### 整合 PAL 工具（可選）

```python
# 深度思考複雜問題
await mcp__pal__thinkdeep({
    "step": "分析為什麼批量生成會失敗",
    "findings": "記憶體在第 5 張圖時耗盡",
    "hypothesis": "沒有正確釋放 GPU 記憶體",
    ...
})

# 多模型驗證方案
await mcp__pal__consensus({
    "step": "評估三種解決方案的可行性",
    "models": [
        {"model": "gpt-5", "stance": "for"},
        {"model": "gemini-2.5-pro", "stance": "against"}
    ],
    ...
})
```

### 整合 GitHub Copilot Agent Skills

由於記憶存於 `.claude/memory/`，GitHub Copilot 也能讀取這些經驗：

```
.github/
├── skills/           # Copilot Agent Skills
│   └── your-skills/
└── memory/           # 共享記憶（Claude + Copilot 都能用）
    └── ...
```

---

## 範例執行過程

```markdown
用戶：/evolve 建立一個能批量生成遊戲道具圖片的系統

Agent：
📋 目標分析完成

目標：建立批量遊戲道具圖片生成系統
驗收標準：
- 能一次生成 10+ 張道具圖片
- 風格一致
- 背景透明
- 解析度 512x512

🔍 搜尋過去經驗...
Grep(pattern="遊戲道具|圖片生成", path=".claude/memory/")
→ 無相關記錄

子目標：
1. ✅ 確認 ComfyUI 環境
2. 🔄 建立基礎工作流程
3. ⏳ 加入風格控制（LoRA）
4. ⏳ 實作批量生成
5. ⏳ 輸出格式處理

---

🔄 執行子目標 2：建立基礎工作流程

Plan：建立 text-to-image 基本流程
Do：[建立工作流程...]
Check：❌ 失敗 - 生成的圖片有背景

📝 反思：
- 問題：預設輸出不是透明背景
- 原因：沒有使用適當的模型和後處理
- 學習需求：如何生成透明背景圖片

🔍 搜索中...
[WebSearch: "ComfyUI transparent background PNG game assets"]

📚 學到：
- 需要使用 Remove Background 節點
- 或使用專門的 icon 生成模型

Act：更新策略，加入背景移除步驟

💾 記錄失敗經驗
Write(.claude/memory/failures/2025-01-05-comfyui-background.md)

---

🔄 重試子目標 2

Plan：加入 RemBG 節點移除背景
Do：[更新工作流程...]
Check：✅ 成功 - 背景已透明

💾 儲存成功經驗
Write(.claude/memory/learnings/2025-01-05-comfyui-rembg.md)
Edit(.claude/memory/index.md) → 更新索引

---

繼續下一個子目標...
```

---

## 涌現機制 (v3.6 新增)

系統透過三個關鍵機制實現真正的自我進化：

| 機制 | 說明 | 效果 |
|------|------|------|
| **多階技能路由** | 粗分類 → Top-K 候選 → 組合策略 | 精準匹配，避免技能庫混亂 |
| **技能效果記分板** | 追蹤成功率、迭代次數、最佳組合 | 自動選擇歷史最優路徑 |
| **知識蒸餾** | 成功經驗 → 可重用技能/策略 | 從「會做」到「會教自己做」 |

詳見：[涌現機制設計文檔](docs/EMERGENCE.md)

### 涌現觸發條件 (Emergence Triggers)

#### 自動觸發（內建信號）

當以下情況發生時，系統自動進入探索模式：

| 信號 | 行為 | 範例 |
|------|------|------|
| 連續成功 3+ 次 | 嘗試更高難度的變體 | 「都成功了，試試更有挑戰的目標？」 |
| 發現 skill 之間的連結 | 記錄並嘗試組合 | 「marketing + game-design = 遊戲化行銷？」 |
| 完成任務後有剩餘迭代 | 探索「還能做什麼」 | 「還有 3 次迭代，探索一下？」 |
| 用戶給予開放性目標 | 主動提出多個方向 | 「讓它變得更好」→ 提出 3 個具體方向 |
| 發現可重用模式 | 提議抽象化 | 「這個模式出現 3 次了，要不要變成 skill？」 |

#### 手動觸發（Flags）

```bash
# 探索模式 - 允許自主選擇方向
/evolve [目標] --explore

# 涌現模式 - 啟用跨領域連結探索
/evolve [目標] --emergence

# 自主模式 - 完全自主，追求系統性創新
/evolve [目標] --autonomous

# 組合使用
/evolve 改進專案架構 --explore --emergence --max-iterations 10
```

#### 涌現等級 (Emergence Levels)

| Level | 名稱 | 行為 | 觸發方式 |
|-------|------|------|----------|
| 0 | 基礎 | 嚴格執行指定任務 | 預設模式 |
| 1 | 探索 | 完成後探索相關改進 | `--explore` 或連續成功 |
| 2 | 涌現 | 主動尋找跨領域連結 | `--emergence` 或發現連結 |
| 3 | 自主 | 自主發現和追求創新 | `--autonomous` |

```
Level 0          Level 1          Level 2          Level 3
基礎模式         探索模式         涌現模式         自主模式
   │                │                │                │
   ▼                ▼                ▼                ▼
執行任務    →   探索相關    →   跨域連結    →   自主創新
   │                │                │                │
   └── 逐步提升 ──→├── 信號觸發 ──→├── 累積經驗 ──→┘
```

### 涌現記錄格式

發現值得記錄的涌現時，寫入 `.claude/memory/discoveries/`：

```yaml
# .claude/memory/discoveries/YYYY-MM-DD-discovery-name.md
---
date: 2024-01-15
type: connection | pattern | insight | hypothesis
confidence: high | medium | low
related_skills: [skill-a, skill-b]
---

## 發現

[描述發現的內容]

## 觸發情境

[什麼情況下發現的]

## 潛在應用

[可能的應用方向]

## 後續行動

- [ ] 驗證假設
- [ ] 建立新 skill
- [ ] 整合到現有機制
```

## 相關資源

- [Reflexion Paper](https://arxiv.org/abs/2303.11366)
- [OpenAI Self-Evolving Agents Cookbook](https://cookbook.openai.com/examples/partners/self_evolving_agents/autonomous_agent_retraining)
- [Andrew Ng - Agentic Design Patterns](https://www.deeplearning.ai/the-batch/agentic-design-patterns-part-2-reflection/)
- [AutoPDL Paper](https://arxiv.org/abs/2504.04365)
- [GitHub Copilot Agent Skills](https://docs.github.com/en/copilot/concepts/agents/about-agent-skills)
